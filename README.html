<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<meta name="author" content="Caspar Moritz Gerland" />
<meta name="date" content="20.03.2024" />
<title>README - German in-kind Military Commitments to Ukraine</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 8954 2022-01-20 10:10:25Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See https://docutils.sourceforge.io/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="readme-german-in-kind-military-commitments-to-ukraine">
<h1 class="title">README - German in-kind Military Commitments to Ukraine</h1>
<h2 class="subtitle" id="to-the-lovely-folks-ust"><em>To the lovely folks &#64;UST</em></h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Caspar Moritz Gerland</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.0</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>20.03.2024</td></tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#quickstart-info" id="toc-entry-1">0. Quickstart info</a></li>
<li><a class="reference internal" href="#purpose-and-introduction" id="toc-entry-2">1. Purpose and Introduction</a></li>
<li><a class="reference internal" href="#required-packages" id="toc-entry-3">2. Required packages</a></li>
<li><a class="reference internal" href="#walk-through-the-code" id="toc-entry-4">3. Walk-Through the code</a><ul>
<li><a class="reference internal" href="#lists-etc" id="toc-entry-5">3.1. lists etc.</a></li>
<li><a class="reference internal" href="#main" id="toc-entry-6">3.2. <em>main()</em></a><ul>
<li><a class="reference internal" href="#timeframes" id="toc-entry-7">3.2.1. Timeframes</a></li>
<li><a class="reference internal" href="#functions-in-main" id="toc-entry-8">3.2.2. Functions in <em>main()</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#scrapedate" id="toc-entry-9">3.3. <em>scrapedate()</em></a></li>
<li><a class="reference internal" href="#scrape-list" id="toc-entry-10">3.4. <em>scrape_list()</em></a><ul>
<li><a class="reference internal" href="#unconcatenate" id="toc-entry-11">3.4.1. <em>unconcatenate()</em></a></li>
<li><a class="reference internal" href="#million" id="toc-entry-12">3.4.2. <em>million()</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#scrape-list-bpa" id="toc-entry-13">3.5. <em>scrape_list_bpa()</em></a></li>
<li><a class="reference internal" href="#add-doubles" id="toc-entry-14">3.6. <em>add_doubles()</em></a></li>
<li><a class="reference internal" href="#set-dimensions" id="toc-entry-15">3.7. <em>set_dimensions()</em></a></li>
<li><a class="reference internal" href="#write-to-df-delivered" id="toc-entry-16">3.8. <em>write_to_df_delivered()</em></a><ul>
<li><a class="reference internal" href="#calculate-change-delivered-row-df-deli" id="toc-entry-17">3.8.1. <em>calculate_change_delivered(row, df_deli)</em></a></li>
<li><a class="reference internal" href="#strip-dataframes" id="toc-entry-18">3.8.2. <em>strip_dataframes()</em></a></li>
<li><a class="reference internal" href="#strip-target-weapon" id="toc-entry-19">3.8.3. <em>strip_target_weapon()</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#write-to-df-committed" id="toc-entry-20">3.9. <em>write_to_df_committed()</em></a><ul>
<li><a class="reference internal" href="#calculate-change-committed-row-df-comm" id="toc-entry-21">3.9.1. <em>calculate_change_committed(row, df_comm)</em></a></li>
<li><a class="reference internal" href="#newly-delivered" id="toc-entry-22">3.9.2. <em>newly_delivered()</em></a></li>
<li><a class="reference internal" href="#newly-committed" id="toc-entry-23">3.9.3. <em>newly_committed()</em></a></li>
<li><a class="reference internal" href="#last-occurrence" id="toc-entry-24">3.9.3. <em>last_occurrence()</em></a></li>
<li><a class="reference internal" href="#new-entry" id="toc-entry-25">3.9.4. <em>new_entry()</em></a></li>
<li><a class="reference internal" href="#cleanup-committed-and-cleanup-delivered" id="toc-entry-26">3.10. <em>cleanup_committed()</em> and <em>cleanup_delivered()</em></a></li>
<li><a class="reference internal" href="#try-convert-to-int" id="toc-entry-27">3.11. <em>try_convert_to_int()</em></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-the-code-doesn-t-capture" id="toc-entry-28">4. What the code doesn't capture</a></li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="quickstart-info">
<h1><a class="toc-backref" href="#toc-entry-1">0. Quickstart info</a></h1>
<ul class="simple">
<li>Scrape the whole period in <em>main()</em> using YYYYMMDD. The first snapshot is 20220623. As of end February 2024 this takes ~6 hours.</li>
<li>One month takes roughly 10 minutes, so unless you're changing the code don't run it over the entire period because it takes time. There is a .xslx file in the Dropbox with the entire period up until February 2024.</li>
<li>The current name of the Excel output is military_output.xslx, rename it as you wish</li>
</ul>
</div>
<div class="section" id="purpose-and-introduction">
<h1><a class="toc-backref" href="#toc-entry-2">1. Purpose and Introduction</a></h1>
<p>This code uses the Wayback Machine to access all existing snapshots of the <a class="reference external" href="https://www.bundesregierung.de/breg-en/news/military-support-ukraine-2054992">German military overview page</a>
over time. It compares committed and delivered entries and writes them to an excel file. The final product is an excel file that contains the development
of deliveries and commitments for the desired period. The whole point of writing the script was to get a quicker overview of changes that occured on the
German website. More precisely it captures all available snapshots, which makes tracking over time much easier.</p>
</div>
<div class="section" id="required-packages">
<h1><a class="toc-backref" href="#toc-entry-3">2. Required packages</a></h1>
<dl class="docutils">
<dt>The main packages used that require pip install are:</dt>
<dd><ul class="first last simple">
<li>requests</li>
<li>BeautifulSoup</li>
<li>pandas</li>
<li>fuzzywuzzy</li>
</ul>
</dd>
</dl>
<p>To be able to run the code, follow these steps:</p>
<ol class="arabic simple">
<li>Open Python interpreter</li>
<li><dl class="first docutils">
<dt>Open cmd Terminal and navigate to the directory where you saved all the files that you downloaded</dt>
<dd><ul class="first last">
<li>cd &quot;put path here&quot;</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Once you're in the folder containing this README, the .py file and a requirements.txt file, create a virtual environment</dt>
<dd><ul class="first last">
<li>python -m venv myenv        # for Windows</li>
<li>python3 -m venv myenv       # For Unix/Mac</li>
<li>You can rename the environment as you wish, myenv is just an example.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Activate the environment</dt>
<dd><ul class="first last">
<li>source myenv/bin/activate   # For Unix/Mac</li>
<li>myenvScriptsactivate      # For Windows</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Install the dependencies from the requirements.txt file</dt>
<dd><ul class="first last">
<li>pip install -r requirements.txt</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>With all required packages and their specified versions installed, you can now run the python file</dt>
<dd><ul class="first last">
<li>python filename.py</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="walk-through-the-code">
<h1><a class="toc-backref" href="#toc-entry-4">3. Walk-Through the code</a></h1>
<div class="section" id="lists-etc">
<h2><a class="toc-backref" href="#toc-entry-5">3.1. lists etc.</a></h2>
<ul class="simple">
<li>Start Dataframes for all committed and delivered values</li>
<li>Start a lists to store all dates, as well as all weapon entries (committed and delivered) and indices used (more on that later)</li>
<li>Start some indices for counting days as well as the amount of timeouts</li>
<li>european_countries is used to clean entries (more on that later)</li>
</ul>
</div>
<div class="section" id="main">
<h2><a class="toc-backref" href="#toc-entry-6">3.2. <em>main()</em></a></h2>
<p>The detailed description of the individual functions in <em>main()</em> can be found Chapter XXX.</p>
<div class="section" id="timeframes">
<h3><a class="toc-backref" href="#toc-entry-7">3.2.1. Timeframes</a></h3>
<p>Core of the script. We first define the maximum days and months in a year. The URL we're scraping only changes in a 14 digit number combination.
Example URL: <a class="reference external" href="https://web.archive.org/web/20230314113747/https://www.bundesregierung.de/breg-en/news/military-support-ukraine-2054992">https://web.archive.org/web/20230314113747/https://www.bundesregierung.de/breg-en/news/military-support-ukraine-2054992</a>.
The 14 digits represent YYYYMMDDhhmmss. We assume that there will be only one change each day at most, so we can ignore the hhmmss and set it to 999999.
The URL then automatically uses the last used entry of that day. The same logic applies to months. If we're trying to access the 31st of February, it resets
to the either the 28th or 29th.The code then iterates over all dates starting from variable_urlpart until the whileloop is satisfied.
<strong>This is also where you can input the timeframe you're interested in.</strong> Inside the while loop, we first check if the last two digits
can still represent a day (are smaller than 32) and if they are, we add one day. If we're at a month brake, we add one month (100) and substract 30 days
to set the counter back to the first of the month. When at a year break, we add one year (10000), substract 11 months (1100) and 30 days to get to the
first day of the first month of the new year.</p>
</div>
<div class="section" id="functions-in-main">
<h3><a class="toc-backref" href="#toc-entry-8">3.2.2. Functions in <em>main()</em></a></h3>
<p>Inside the three subcategories (day, month or year change) the operations are the same, so let's go through the day change. After adding one day to the counter,
we try to use the <em>scrapedate()</em> function with that variable_urlpart in order to retrieve the date on the website (the date the website was updated) as well as the
full URL. We need to use try, because some Wayback URLs are faulty and just redirect to some other website which we want to avoid. If we can get a website date
and that date is not in the website date list yet, we append it to the website list. That way we ensure that the code only runs over new instances of the website
so that we only have unique entries.
Then we run into a little extra step. The HTML structure on the German site changed briefly at the end of 2022 from unordered lists and nice bullets to bpa_richtext.
To capture this change, we use a slightly different scraping method for this period with <em>scrape_list_bpa()</em>. For the rest of the timeframe, we use <em>scrape_list()</em>.
Both scraping methods return amount_committed, weapon_committed, amount_delivered, weapon_delivered which are the already cleaned entries from the website, split up
in amounts/weapons and commitments/deliveries. These then get passed in <em>add_doubles()</em>, which adds up entries, should there be the same entry twice. This sounds weird,
but happens.
Afterwards, <em>set_dimensions()</em> is used to calculate the maximum length of the amount/weapon lists as well as the corresponding dataframe. We then calculate the
overall maximum length of all lists/dataframes to ensure that all of them are always of same length. We need this because we otherwise run into IndexErrors when
matching entries later on. Shorter lists are just extended with empty strings.
Then, we write the amounts/weapons to the corresponding dataframe using <em>write_to_df_delivered()</em>. This function also triggers the calculations for changes that
occured over time (more on that later).
Finally, we apply <em>cleanup_committed()</em> and <em>cleanup_delivered()</em> to the dataframes to strip away excess dummies (some are just applied to every cell naively in the
beginning and then overwritten). Afterwards, we update the date_index dummy to ensure correct indexing for the next entry.</p>
<p>Once the while loop has terminated, we use <em>try_convert_to_int()</em> on both dataframes to convert all integers that are saved as strings to integers.
Finally, we write both dataframes to a sheet in the same excel, freezing the top row for better readability. <em>main()</em> is the only operation called outside functions.</p>
</div>
</div>
<div class="section" id="scrapedate">
<h2><a class="toc-backref" href="#toc-entry-9">3.3. <em>scrapedate()</em></a></h2>
<p>This function takes the variable_urlpart as input and accesses the URL to find all spans of class bpa-time. The date_text then converts it into a string. The re
part finds all matches in dates that contain a prefix of a weekday. It does so, because we always only have one date formatted like this: &quot;Monday, 26 February 2024&quot;
The if matches: part adds another layer of checks, in that we only continue if we're on the correct website that contains a date in the desired format.
We then time out the function to avoid being kicked from accessing Wayback and print a small update statement on where we are in the process.
The function returns the clean dates just containing the date and the full URL.</p>
</div>
<div class="section" id="scrape-list">
<h2><a class="toc-backref" href="#toc-entry-10">3.4. <em>scrape_list()</em></a></h2>
<p>This function takes the full text in the HTML code and looks for the unique word &quot;handover&quot;. Once it has found it, it splits the full string at that word. Handover
is always used in the brief sentence dividing commitments from deliveries, so we use it for splitting. We then clean both the delivered and committed strings from
HTML tags and markups, as well as &quot;more than &quot; (only occurs in combination with integers &quot;more than 3000 guns&quot; anyways).Then, <em>unconcatenate()</em> makes sure that all bullet points
only contain single entries. If doubles occur (&quot;- 13 guns and 2 tanks&quot;), they get split into two seperate entries. We also remove the &quot;(before: 12 units)&quot;for
higher matching precision. After doing this, we pass all entries through <em>million()</em> which removes 1,000's seperators and turns &quot;1.3 million&quot; to &quot;1300000&quot;.
Then we write the amount and corresponding item to two seperate lists (for committed and delivered) and return the four lists. They're then passed into <em>add_doubles()</em>.</p>
<div class="section" id="unconcatenate">
<h3><a class="toc-backref" href="#toc-entry-11">3.4.1. <em>unconcatenate()</em></a></h3>
<p><em>unconcatenate()</em> looks for entries that contain and &quot;and&quot; followed by an int (e.g. &quot;34 horses and 3 cows&quot;) using regular expressions. If doubles are found, we save
the number (here 3), as we use the more rare instance of &quot;and 3&quot; rather than &quot;and&quot; to split the entry. We then add the number with the last part of the split entry
(&quot;3&quot; with &quot;cows&quot;) and append both parts to a list that then gets returned to the scraping function [&quot;34 horses&quot;, &quot;3 cows&quot;]. If no doubles occur, nothing happens.</p>
</div>
<div class="section" id="million">
<h3><a class="toc-backref" href="#toc-entry-12">3.4.2. <em>million()</em></a></h3>
<p><em>million()</em> first checks if the first letter/integer is an integer (e.g. &quot;3.5 million guns of type X&quot; -&gt; 3 is an int). It then splits the whole entry in each word and tries to convert
the second word into actual millions. input_str_weapon resembles the weapon description (&quot;guns of type X&quot;). The try statement then attempts to replace any &quot;.&quot; or
&quot;,&quot; in the amounts if we don't find millions (e.g. &quot;120,000&quot;) and turns it to an integer. If that fails, we mark the amount as &quot;undisclosed&quot;. Similarly if there's
no number at all, mark the amount as &quot;undisclosed&quot;. We finally reconcatenate amounts and weapon description and return it to <em>scrape_list()</em>.</p>
</div>
</div>
<div class="section" id="scrape-list-bpa">
<h2><a class="toc-backref" href="#toc-entry-13">3.5. <em>scrape_list_bpa()</em></a></h2>
<p>Same logic as in 3.4., we also split at &quot;handover&quot;. For the delivered entries we then split the remainder again after the first occurence of a bullet point. The part
.split(&quot;Military&quot;)[0] gets rid of the statement that is in between deliveries and commitments. Finally, we split the list at each bullet point to have a clean list of
only the entries we want. We do the same for commitments with the only difference that the cutoff in the end is a different string. The remaining procedure is
equal to <em>scrape_list()</em></p>
</div>
<div class="section" id="add-doubles">
<h2><a class="toc-backref" href="#toc-entry-14">3.6. <em>add_doubles()</em></a></h2>
<p>Now that we have almost completely cleaned the raw data, we add double entries. They can happen due to sloppyness, but more likely because <em>unconcatenate()</em> has
split entries into two. Say we have one bullet &quot;3 trucks and 4 guns&quot; and one is &quot;3 guns&quot;. After unconcatenating, we have two entries for &quot;guns&quot;, so we add them together
here. First the function populates a dictionary with the amounts and weapons and then iterates over all entries in that dictionary to see if it already occured.
If we can turn the amount to an integer, we save the old amount and update the amount with new_int + old_int in a new dictionary. If the amount is not an integer,
we just save the weapon with its non-numeric amount. If there is no double occurrence, nothing happens. Finally, we clear the input lists and populate them with
the updated ones that then get returned.</p>
</div>
<div class="section" id="set-dimensions">
<h2><a class="toc-backref" href="#toc-entry-15">3.7. <em>set_dimensions()</em></a></h2>
<p>Calculates the maximum length of the amount list, the weapon list (both should be of same length already, just for good measure), and the dataframe and returns
an integer.</p>
<hr class="docutils" />
<p><strong>Now we get to the heart of the code, which is calculating the changes over time.</strong></p>
</div>
<div class="section" id="write-to-df-delivered">
<h2><a class="toc-backref" href="#toc-entry-16">3.8. <em>write_to_df_delivered()</em></a></h2>
<p>This function starts by defining headers and then populates a dictionary. It then fills the first two columns with the amount and weapon and leaves the rest blank. The last column is just a visual seperator. Then it turns the newly created
dictionary into a dataframe. It now looks like this:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="20%" />
<col width="23%" />
<col width="9%" />
<col width="18%" />
<col width="13%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Date Amount</th>
<th class="head">Date Description</th>
<th class="head">Date Last Occurrence [Dummy]</th>
<th class="head">Date Change</th>
<th class="head">Date New Item [Dummy]</th>
<th class="head">Date HUMAN CHECK</th>
<th class="head">Date #</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>23</td>
<td>pigs</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>#</td>
</tr>
<tr><td>undisclosed</td>
<td>ammunition for tank</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>#</td>
</tr>
</tbody>
</table>
<p>The Date ensures that every column will always have unique headers and we can easily identify entries.</p>
<ul class="simple">
<li>Amount shows the Amount of the respective entry</li>
<li>Description is self explanatory</li>
<li>Last Occurrence (Yes/No) indicates if this is the last date at which this item appeared. Watch out for merged entries at the next date, deliveries usually don't disappear</li>
<li>Change marks the change from the previous amount to the current amount</li>
<li>New Item (Yes/No) indicates if this is the first time this item is showing up</li>
<li>HUMAN CHECK flags entries that either show higher than usual changes, or instances where the match was fuzzy</li>
</ul>
<p>If we have more than one entry, we apply the function <em>calculate_change_delivered()</em>. In the end, the matched_indices_change_delivered list gets cleared (more detailed info on that later). It ensures that when we match
a current entry against the past ones and find a match, we match against that entry only once. The function returns the now populated dataframe.</p>
<div class="section" id="calculate-change-delivered-row-df-deli">
<h3><a class="toc-backref" href="#toc-entry-17">3.8.1. <em>calculate_change_delivered(row, df_deli)</em></a></h3>
<p>Calling df_delivered.apply(calculate_change_delivered, axis=1, df_deli=df_delivered) applies the function to each row in the delivered dataframe, hence the inputs
row and df_deli.
The matching process uses the Levenshtein distance between words (minimum changes necessary to transform word A to word B). First we set the variables best_match_index
and best_match_score to -1. Since the Levenshtein score ranges from [0, 100], we'll always get a match such that the index/score updates. Then, we define the target weapon. This
is the weapon we're trying to find among the previous entries. Before we get to the matching, we apply <em>strip_target_weapon()</em> to the target weapon and <em>strip_dataframes()</em>
to the delivered dataframe. This increases matching precision as it clears away unnecessary words (more in Section XXX). With target weapon and dataframe cleaned we start
matching. We iterate through all entries under the previous description and calculate a similarity score between new entry and old entry.
If that score is higher than the current best_match_score, we update the score as well as the index. Like this, the current entry gets matched against every single one of the previous entries even
if we already have a perfect match (score = 100). If the best_match_score is higher than 80, meaning that matching entries are relatively similar, we calculate the change
from past to current amount. To ensure that matches that match 1:1, are excluded from further matching, we write the best_match_index to a list and only execute the
matching if the current index is not in the list of &quot;perfect match indices&quot;.
We then try to calculate the difference between the two amounts. If that change is 0, we mark it as &quot;no change&quot;. If we have one or more undisclosed amounts, we
mark the change as &quot;no change&quot; as we cannot say by how much amounts did change. Additionally, we mark the New Item [Dummy] column as &quot;no&quot;, since we have a match.
If we don't surpass the critical value of 80, we mark that entry as new.
Finally, we write the calculated change to the Change column. We then populate the HUMAN CHECK column if the match was not perfect (best_match_score != 100), or if
the change is larger than 1000 or negative with &quot;CHECK&quot; or &quot;no&quot; otherwise.</p>
</div>
<div class="section" id="strip-dataframes">
<h3><a class="toc-backref" href="#toc-entry-18">3.8.2. <em>strip_dataframes()</em></a></h3>
<p>The function preprocesses the dataframes to increase matching precision even further. It is only used to match entries, the writing to the dataframe happens at
the original dataframe which has the same structure.
Here, we strip away any &quot;with....&quot;, &quot;(including .... )&quot;, &quot;including ....&quot;, (from Bundeswehr and industry stocks). Entries are still unique matching after cleaning,
we are just able to increase precision, because sometimes the govenment changes the entries from &quot;tank&quot; to &quot;tank with training equipment&quot;, which still is the same
tank, just the Levenshtein score decreased drastically. The function also gets rid of any brackets that include country names, or the names or their nationals using
the initially defined european_countries and regular expressions. This furthermore increases matching precisions as again the &quot;54 M113 armoured personnel carriers (systems of Denmark, upgrades financed by Germany)&quot;
are the same APCs as &quot;54 M113 armoured personnel carriers (systems of Denmark)&quot;.
Finally the code returnes the stripped dataframe.</p>
</div>
<div class="section" id="strip-target-weapon">
<h3><a class="toc-backref" href="#toc-entry-19">3.8.3. <em>strip_target_weapon()</em></a></h3>
<p>This function essentially does the same thing as <em>strip_dataframes()</em> just for the target weapon and not for a dataframe.</p>
</div>
</div>
<div class="section" id="write-to-df-committed">
<h2><a class="toc-backref" href="#toc-entry-20">3.9. <em>write_to_df_committed()</em></a></h2>
<p>The function is triggered after <em>write_to_df_delivered()</em> because it relies no entries in the delivered dataframe. It essentially performs the same things as it's
predecessor and produces the following table layout:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="12%" />
<col width="14%" />
<col width="8%" />
<col width="11%" />
<col width="10%" />
<col width="21%" />
<col width="9%" />
<col width="5%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Date Amount</th>
<th class="head">Date Description</th>
<th class="head">Date Last Occurrence [Dummy]</th>
<th class="head">New Item [Dummy]</th>
<th class="head">Date Newly Committed</th>
<th class="head">Date Newly Delivered</th>
<th class="head">Date Previous Commitment increased [Dummy]</th>
<th class="head">Date HUMAN CHECK</th>
<th class="head">Date #</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>23</td>
<td>pigs</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>#</td>
</tr>
<tr><td>undisclosed</td>
<td>ammunition for tank</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>#</td>
</tr>
</tbody>
</table>
<p>The new Columns are:</p>
<ul class="simple">
<li>Newly Committed shows changes in commitments (more on that later)</li>
<li>Newly Delivered shows changes in deliveries (same as Changes in 3.8.)</li>
<li>Previous Commitment increased [Dummy] (1/0) indicates if the previous instances had its amount and Newly Committed entry changed retrospectively</li>
</ul>
<p>If we have more than one entry, we apply the function <em>calculate_change_committed()</em>. In the end, the matched_indices_XXX lists gets cleared. It again ensures that when we match
a current entry against the past ones and find a match, we match against that entry only once. The function returns the now populated dataframe.</p>
<p>Before we get into the <em>calculate_change_committed()</em>, here is a preview how it handles some example cases:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="9%" />
<col width="8%" />
<col width="9%" />
<col width="15%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Committed_old</th>
<th class="head">Delivered_old</th>
<th class="head">Committed_new</th>
<th class="head">Delivered_new</th>
<th class="head">New Item [Dummy]</th>
<th class="head">Newly Committed</th>
<th class="head">Newly Delivered</th>
<th class="head">Previous Commitment changed [Dummy]</th>
<th class="head">Case</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td>33</td>
<td>1</td>
<td>44</td>
<td>1</td>
<td>No</td>
<td>11</td>
<td>no change</td>
<td>0</td>
<td>Newly Delivered &lt; Committed_old</td>
</tr>
<tr><td>2</td>
<td>10</td>
<td>10</td>
<td>30</td>
<td>20</td>
<td>No</td>
<td>30</td>
<td>10</td>
<td>0</td>
<td>Newly Delivered &lt; Committed_old</td>
</tr>
<tr><td rowspan="2">3  (raw/new)</td>
<td>10000</td>
<td>0</td>
<td>0</td>
<td>10500</td>
<td>No</td>
<td>500</td>
<td>10500</td>
<td rowspan="2">1</td>
<td rowspan="2">Newly Delivered &gt; Committed_old</td>
</tr>
<tr><td>10500</td>
<td>0</td>
<td>0</td>
<td>10500</td>
<td>No</td>
<td>no change</td>
<td>10500</td>
</tr>
<tr><td rowspan="2">4  (raw/new)</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>No</td>
<td>4</td>
<td>4</td>
<td rowspan="2">1</td>
<td rowspan="2">Newly Delivered &gt; Committed_old</td>
</tr>
<tr><td>4</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>No</td>
<td>1</td>
<td>4</td>
</tr>
<tr><td>5</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>0</td>
<td>Yes</td>
<td>3</td>
<td>no change</td>
<td>0</td>
<td>New Item</td>
</tr>
<tr><td>6</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>Yes</td>
<td>6</td>
<td>3</td>
<td>0</td>
<td>New Item</td>
</tr>
<tr><td>7</td>
<td>undisclosed</td>
<td>undisclosed</td>
<td>3</td>
<td>3</td>
<td>No</td>
<td>undisclosed</td>
<td>undisclosed</td>
<td>0</td>
<td>undisclosed amounts</td>
</tr>
</tbody>
</table>
<p><em>Note that 0's in column 2-5 would be empty entries in the real dataframe (just there for illustrative purposes)</em></p>
<p>We always assume that deliveries first draw from the existing &quot;stock&quot; in Committed_old before new amounts get committed.</p>
<ul class="simple">
<li>If the Newly Delivered value is larger than the Committed_old value like in the first two cases, the algorithm first calculates the difference in deliveries and then the change in commitments. Since deliveries must be committed first, Newly Committed = Delivered_new - Delivered_old + Newly Delivered.</li>
<li>Should Committed_old be smaller than Newly Delivered, this would apply that some of the deliveries appeared out of the blue. To correctly account for that, we retrospectively change the Old Commitment to match Newly Delivered. Following this logic, we also change the Newly Committed value accordingly.</li>
<li>If there's a new Item, the above logic doesn't apply. However, we still add Newly Committed = Delivered_new - Delivered_old + Newly Delivered.</li>
<li>In case of undisclosed amounts we mark Newly Committed and/or Newly Delivered as undisclosed as well, since we cannot say for sure by how much numbers changed even if we know the final level.</li>
</ul>
<div class="section" id="calculate-change-committed-row-df-comm">
<h3><a class="toc-backref" href="#toc-entry-21">3.9.1. <em>calculate_change_committed(row, df_comm)</em></a></h3>
<p>This function is applied the same way as <em>calculate_change_delivered()</em>. It first creates a clean version of both dataframes using <em>strip_dataframes()</em>.
We then populate the Newly Delivered column using <em>newly_delivered()</em>, then the Newly Committed column using <em>newly_committed()</em>. Then we deal with cases
where entries appear for the last time using <em>last_occurrence()</em> and finally check for new deliveries without a commitment using <em>new_entry()</em>.</p>
</div>
<div class="section" id="newly-delivered">
<h3><a class="toc-backref" href="#toc-entry-22">3.9.2. <em>newly_delivered()</em></a></h3>
<p>Here, we go through all entries under the current Description in the committed dataframe and try to match them against the entries in the delivered dataframe.
The matching process is the same as in <em>calculate_change_committed(row, df_comm)</em>. If we find a match, we write the Change from the delivered dataframe
to the matched entry under Newly Delivered. If we don't find a match, we simply mark that entry as &quot;no change&quot;.</p>
</div>
<div class="section" id="newly-committed">
<h3><a class="toc-backref" href="#toc-entry-23">3.9.3. <em>newly_committed()</em></a></h3>
<p>The matching process is always the same, this time we're matching against the previous entries of the same committed dataframe. We also again use the unique matching,
if the match achieves a 100% match. When a match is found, we try to calculate the difference in commitments. If the integer conversion fails, we try to convert the
new commitment into an integer. Like this we can capture the case where an undisclosed amount becomes an integer. If all that doesn't work, we write &quot;no change&quot; to
the Newly Committed column. We then also set the New Item Dummy to &quot;No&quot;.
If we don't achieve a match of 75, we mark that entry as new and set Newly Committed to Amount.
The next chunk of code tries to convert the Newly Delivered amount to an int, and if both Newly Committed and Newly Delivered are integers, they get added up and written to Newly Committed.
Now we update the previous Amount as well as the previous Newly Committed entry if Newly Delivered (current) &gt; Amount (old) assuming that everything needs to be committed before it can be delivered.
The first part here ensures that we find the correct index of the values we're trying to compare. We then prematurely write all Previous Commitment Increased Dummies to &quot;No&quot; to then only change the instances where we did change the previous commitment.
If we find a match and the try statement are True, we compare newly_delivered_int with old_committed_int and if that is also True, we update the previous Amount, correct the current Newly Committed entry,
which by design will be equal to the just corrected old Amount. We also update the old Newly Committed value which is now new_old_committed_int - old_committed_int + old_newly_committed_int
to make sense of the changes in the previous Amount. After marking the corresponding Dummy with &quot;Yes&quot;, we run <em>human_check()</em> with the correct rows and best_match_scores. This function is equal to what is implemented in <em>calculate_change_delivered(row, df_deli)</em> already.</p>
</div>
<div class="section" id="last-occurrence">
<h3><a class="toc-backref" href="#toc-entry-24">3.9.3. <em>last_occurrence()</em></a></h3>
<p>This function populates the Last Occurrence [Dummy] column. After stripping the dataframe again using <em>strip_dataframes()</em>, it prematurely marks all previous entries with &quot;Yes&quot;,
then it looks for current entries that are not marked as new. It takes the corresponding description of that entry and performs fuzzy matching just as seen before.
If a match is found, this must mean that it's not the last time that the item appeared (it also appears at the current date), so we mark the Dummy with &quot;No&quot;.</p>
</div>
<div class="section" id="new-entry">
<h3><a class="toc-backref" href="#toc-entry-25">3.9.4. <em>new_entry()</em></a></h3>
<p><em>new_entry()</em> looks for new deliveries without commitments and writes those to the committed dataframe (all within the same date). Therefore, we check all entries
that are marked as new in the delivered dataframe, retrieve its Description and write all committed Descriptions to a list. If the new item from the delivered column
is not on that list, we get the corresponding values of those cases. To avoid overwriting already filled entries we then get the indices of blank Descriptions and write
the deliveries without commitment to the committed dataframe at these indices. Together with the Previous Commitment Increased [Dummy] column, this ensures that
all deliveries are committed (latest at the point of delivery).</p>
</div>
<div class="section" id="cleanup-committed-and-cleanup-delivered">
<h3><a class="toc-backref" href="#toc-entry-26">3.10. <em>cleanup_committed()</em> and <em>cleanup_delivered()</em></a></h3>
<p>These two functions are triggered before the next snapshot is scraped. It ensures that if the Description of a certain row is empty, the other columns are empty as well.
Since we sometimes mark all entries (also empty ones) with e.g. &quot;Yes&quot;, the function cleans those for a clean plate.</p>
</div>
<div class="section" id="try-convert-to-int">
<h3><a class="toc-backref" href="#toc-entry-27">3.11. <em>try_convert_to_int()</em></a></h3>
<p>Finally, we use the map() function to check every cell in both dataframes for integers saved as strings and convert these to integers. This only happens once all entries are scraped
and calculated already, so that we can finally create a two sheet excel.</p>
</div>
</div>
</div>
<div class="section" id="what-the-code-doesn-t-capture">
<h1><a class="toc-backref" href="#toc-entry-28">4. What the code doesn't capture</a></h1>
<p>The code isn't perfect, hence the HUMAN CHECK Dummy. There is however one case that I was unable to detect. If we have a new commitment and simultaneously an increase
in deliveries of that same item, the Newly Committed column only shows the change in commitments that should occur because of the new deliveries. It doesn't add
the Amount of the item under committed to that, so the Newly Committed column would be incorrect here. It gets flagged though and the correct value can easily be calculated
by adding Amount and Newly Committed.</p>
</div>
</div>
</body>
</html>
